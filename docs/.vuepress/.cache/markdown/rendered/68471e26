{"content":"<h2 id=\"vue3-中响应式系统的原理\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#vue3-中响应式系统的原理\"><span>Vue3 中响应式系统的原理？</span></a></h2>\n<p>Vue 3 的响应式系统是其核心架构的重大革新，它采用现代 JavaScript 的 <strong>Proxy API</strong> 替代了 Vue 2 的 <code v-pre>Object.defineProperty</code>，实现了更高效、更全面的数据响应能力。</p>\n<p>当使用 <code v-pre>reactive()</code> 包装一个对象时，Vue 3 会为其创建一个 <strong>Proxy 代理</strong>。这个代理能够<strong>拦截对象的所有操作</strong>——包括属性的读取（get）、设置（set）、添加、删除等。每当您访问响应式对象的属性时，系统会通过 <code v-pre>track()</code> 函数<strong>自动收集依赖</strong>（即哪些组件或计算属性依赖于此数据）；而当您修改数据时，则会通过 <code v-pre>trigger()</code> 函数<strong>精确触发所有相关依赖的更新</strong>。</p>\n<p>对于原始值（如字符串、数字），Vue 3 提供了 <code v-pre>ref()</code> API，它将值包装在一个具有 <code v-pre>.value</code> 属性的对象中，内部同样利用响应式系统进行依赖追踪。而 <code v-pre>computed()</code> 则基于此系统构建，它会自动缓存计算结果，仅在依赖发生变化时才重新计算。</p>\n<p>整个系统围绕 <strong>effect 副作用函数</strong> 运作，组件的渲染、计算属性的求值、侦听器的回调都被包装成 effect。当响应式数据变化时，Vue 3 不会立即执行更新，而是通过<strong>调度器（scheduler）</strong> 将这些更新排队，在下一个微任务中批量执行，这大大提升了性能并避免了不必要的重复渲染。</p>\n<p>了解更多响应式系统信息，请参阅 <VPLink href=\"/web/vue/principle/#%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F\">Vue-设计与实现-响应式系统</VPLink>。</p>\n","env":{"base":"/","filePath":"D:/002-zhy-git/front-end-interview-docs/docs/framework/1.vue/响应式系统.md","filePathRelative":"framework/1.vue/响应式系统.md","frontmatter":{"title":"响应式系统","createTime":"2025/12/01 17:09:33","permalink":"/framework/vue/f43gsc7o/"},"sfcBlocks":{"template":{"type":"template","content":"<template><h2 id=\"vue3-中响应式系统的原理\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#vue3-中响应式系统的原理\"><span>Vue3 中响应式系统的原理？</span></a></h2>\n<p>Vue 3 的响应式系统是其核心架构的重大革新，它采用现代 JavaScript 的 <strong>Proxy API</strong> 替代了 Vue 2 的 <code v-pre>Object.defineProperty</code>，实现了更高效、更全面的数据响应能力。</p>\n<p>当使用 <code v-pre>reactive()</code> 包装一个对象时，Vue 3 会为其创建一个 <strong>Proxy 代理</strong>。这个代理能够<strong>拦截对象的所有操作</strong>——包括属性的读取（get）、设置（set）、添加、删除等。每当您访问响应式对象的属性时，系统会通过 <code v-pre>track()</code> 函数<strong>自动收集依赖</strong>（即哪些组件或计算属性依赖于此数据）；而当您修改数据时，则会通过 <code v-pre>trigger()</code> 函数<strong>精确触发所有相关依赖的更新</strong>。</p>\n<p>对于原始值（如字符串、数字），Vue 3 提供了 <code v-pre>ref()</code> API，它将值包装在一个具有 <code v-pre>.value</code> 属性的对象中，内部同样利用响应式系统进行依赖追踪。而 <code v-pre>computed()</code> 则基于此系统构建，它会自动缓存计算结果，仅在依赖发生变化时才重新计算。</p>\n<p>整个系统围绕 <strong>effect 副作用函数</strong> 运作，组件的渲染、计算属性的求值、侦听器的回调都被包装成 effect。当响应式数据变化时，Vue 3 不会立即执行更新，而是通过<strong>调度器（scheduler）</strong> 将这些更新排队，在下一个微任务中批量执行，这大大提升了性能并避免了不必要的重复渲染。</p>\n<p>了解更多响应式系统信息，请参阅 <VPLink href=\"/web/vue/principle/#%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F\">Vue-设计与实现-响应式系统</VPLink>。</p>\n</template>","contentStripped":"<h2 id=\"vue3-中响应式系统的原理\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#vue3-中响应式系统的原理\"><span>Vue3 中响应式系统的原理？</span></a></h2>\n<p>Vue 3 的响应式系统是其核心架构的重大革新，它采用现代 JavaScript 的 <strong>Proxy API</strong> 替代了 Vue 2 的 <code v-pre>Object.defineProperty</code>，实现了更高效、更全面的数据响应能力。</p>\n<p>当使用 <code v-pre>reactive()</code> 包装一个对象时，Vue 3 会为其创建一个 <strong>Proxy 代理</strong>。这个代理能够<strong>拦截对象的所有操作</strong>——包括属性的读取（get）、设置（set）、添加、删除等。每当您访问响应式对象的属性时，系统会通过 <code v-pre>track()</code> 函数<strong>自动收集依赖</strong>（即哪些组件或计算属性依赖于此数据）；而当您修改数据时，则会通过 <code v-pre>trigger()</code> 函数<strong>精确触发所有相关依赖的更新</strong>。</p>\n<p>对于原始值（如字符串、数字），Vue 3 提供了 <code v-pre>ref()</code> API，它将值包装在一个具有 <code v-pre>.value</code> 属性的对象中，内部同样利用响应式系统进行依赖追踪。而 <code v-pre>computed()</code> 则基于此系统构建，它会自动缓存计算结果，仅在依赖发生变化时才重新计算。</p>\n<p>整个系统围绕 <strong>effect 副作用函数</strong> 运作，组件的渲染、计算属性的求值、侦听器的回调都被包装成 effect。当响应式数据变化时，Vue 3 不会立即执行更新，而是通过<strong>调度器（scheduler）</strong> 将这些更新排队，在下一个微任务中批量执行，这大大提升了性能并避免了不必要的重复渲染。</p>\n<p>了解更多响应式系统信息，请参阅 <VPLink href=\"/web/vue/principle/#%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F\">Vue-设计与实现-响应式系统</VPLink>。</p>\n","tagOpen":"<template>","tagClose":"</template>"},"script":null,"scriptSetup":null,"scripts":[],"styles":[],"customBlocks":[]},"content":"## Vue3 中响应式系统的原理？\n\nVue 3 的响应式系统是其核心架构的重大革新，它采用现代 JavaScript 的 **Proxy API** 替代了 Vue 2 的 `Object.defineProperty`，实现了更高效、更全面的数据响应能力。\n\n当使用 `reactive()` 包装一个对象时，Vue 3 会为其创建一个 **Proxy 代理**。这个代理能够**拦截对象的所有操作**——包括属性的读取（get）、设置（set）、添加、删除等。每当您访问响应式对象的属性时，系统会通过 `track()` 函数**自动收集依赖**（即哪些组件或计算属性依赖于此数据）；而当您修改数据时，则会通过 `trigger()` 函数**精确触发所有相关依赖的更新**。\n\n对于原始值（如字符串、数字），Vue 3 提供了 `ref()` API，它将值包装在一个具有 `.value` 属性的对象中，内部同样利用响应式系统进行依赖追踪。而 `computed()` 则基于此系统构建，它会自动缓存计算结果，仅在依赖发生变化时才重新计算。\n\n整个系统围绕 **effect 副作用函数** 运作，组件的渲染、计算属性的求值、侦听器的回调都被包装成 effect。当响应式数据变化时，Vue 3 不会立即执行更新，而是通过**调度器（scheduler）** 将这些更新排队，在下一个微任务中批量执行，这大大提升了性能并避免了不必要的重复渲染。\n\n了解更多响应式系统信息，请参阅 [Vue-设计与实现-响应式系统](/web/vue/principle/#响应系统)。","excerpt":"","includedFiles":[],"tasklistId":0,"title":"","headers":[{"level":2,"title":"Vue3 中响应式系统的原理？","slug":"vue3-中响应式系统的原理","link":"#vue3-中响应式系统的原理","children":[]}],"links":[{"raw":"/web/vue/principle/","absolute":"/web/vue/principle/","relative":"web/vue/principle"}]}}
