{"content":"<h2 id=\"代码执行结果1\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#代码执行结果1\"><span>代码执行结果1</span></a></h2>\n<p>下面的代码执行结果是什么？</p>\n<ClientOnly>\n  <JSRunner :code=\"code\" :height=\"400\" />\n</ClientOnly>\n<p>这段代码考察变量提升与优先级：函数声明会被提升到作用域顶部，<code v-pre>var</code> 也会被提升，但函数优先级更高，不会覆盖已经存在的同名函数声明。所以上面的代码在执行上下文阶段等效以下代码：</p>\n<div class=\"language-js line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"js\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-js\"><span class=\"line\"><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">function</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> foo</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">()</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">  console</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\">log</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">(</span><span style=\"--shiki-light:#2F798A;--shiki-dark:#4C9A91\">1</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">)</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">}</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">// var foo; ← 被忽略，因为 foo 已由函数声明定义</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">// 调用函数</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\">foo</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">()</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code v-pre>foo</code> 调用时指向的是函数声明。</p>\n","env":{"base":"/","filePath":"D:/002-zhy-git/front-end-interview-docs/docs/basic/JavaScript/6.编码与实现.md","filePathRelative":"basic/JavaScript/6.编码与实现.md","frontmatter":{"title":"编码与实现","createTime":"2025/11/24 14:34:50","permalink":"/basic/javascript/spnc724u/","outline":2},"sfcBlocks":{"template":{"type":"template","content":"<template><h2 id=\"代码执行结果1\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#代码执行结果1\"><span>代码执行结果1</span></a></h2>\n<p>下面的代码执行结果是什么？</p>\n<ClientOnly>\n  <JSRunner :code=\"code\" :height=\"400\" />\n</ClientOnly>\n<p>这段代码考察变量提升与优先级：函数声明会被提升到作用域顶部，<code v-pre>var</code> 也会被提升，但函数优先级更高，不会覆盖已经存在的同名函数声明。所以上面的代码在执行上下文阶段等效以下代码：</p>\n<div class=\"language-js line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"js\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-js\"><span class=\"line\"><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">function</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> foo</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">()</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">  console</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\">log</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">(</span><span style=\"--shiki-light:#2F798A;--shiki-dark:#4C9A91\">1</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">)</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">}</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">// var foo; ← 被忽略，因为 foo 已由函数声明定义</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">// 调用函数</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\">foo</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">()</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code v-pre>foo</code> 调用时指向的是函数声明。</p>\n</template>","contentStripped":"<h2 id=\"代码执行结果1\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#代码执行结果1\"><span>代码执行结果1</span></a></h2>\n<p>下面的代码执行结果是什么？</p>\n<ClientOnly>\n  <JSRunner :code=\"code\" :height=\"400\" />\n</ClientOnly>\n<p>这段代码考察变量提升与优先级：函数声明会被提升到作用域顶部，<code v-pre>var</code> 也会被提升，但函数优先级更高，不会覆盖已经存在的同名函数声明。所以上面的代码在执行上下文阶段等效以下代码：</p>\n<div class=\"language-js line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"js\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-js\"><span class=\"line\"><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">function</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> foo</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">()</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">  console</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\">log</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">(</span><span style=\"--shiki-light:#2F798A;--shiki-dark:#4C9A91\">1</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">)</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">}</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">// var foo; ← 被忽略，因为 foo 已由函数声明定义</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">// 调用函数</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\">foo</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">()</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p><code v-pre>foo</code> 调用时指向的是函数声明。</p>\n","tagOpen":"<template>","tagClose":"</template>"},"script":null,"scriptSetup":{"content":"<script setup>\nlet code = `foo()\nvar foo\nfunction foo(){\n  console.log(1)\n}\n`\n</script>","tagOpen":"<script setup>","type":"script","contentStripped":"\nlet code = `foo()\nvar foo\nfunction foo(){\n  console.log(1)\n}\n`\n","tagClose":"</script>"},"scripts":[{"content":"<script setup>\nlet code = `foo()\nvar foo\nfunction foo(){\n  console.log(1)\n}\n`\n</script>","tagOpen":"<script setup>","type":"script","contentStripped":"\nlet code = `foo()\nvar foo\nfunction foo(){\n  console.log(1)\n}\n`\n","tagClose":"</script>"}],"styles":[],"customBlocks":[]},"content":"## 代码执行结果1\n\n下面的代码执行结果是什么？\n\n<script setup>\nlet code = `foo()\nvar foo\nfunction foo(){\n  console.log(1)\n}\n`\n</script>\n\n<ClientOnly>\n  <JSRunner :code=\"code\" :height=\"400\" />\n</ClientOnly>\n\n这段代码考察变量提升与优先级：函数声明会被提升到作用域顶部，`var` 也会被提升，但函数优先级更高，不会覆盖已经存在的同名函数声明。所以上面的代码在执行上下文阶段等效以下代码：\n\n```js\nfunction foo() {\n  console.log(1)\n}\n// var foo; ← 被忽略，因为 foo 已由函数声明定义\n\n// 调用函数\nfoo()\n```\n\n`foo` 调用时指向的是函数声明。","excerpt":"","includedFiles":[],"tasklistId":0,"title":"","headers":[{"level":2,"title":"代码执行结果1","slug":"代码执行结果1","link":"#代码执行结果1","children":[]}]}}
