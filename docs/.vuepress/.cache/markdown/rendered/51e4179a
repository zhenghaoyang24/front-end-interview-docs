{"content":"<h2 id=\"mvc、mvvm、mvp\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#mvc、mvvm、mvp\"><span>MVC、MVVM、MVP</span></a></h2>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">问题</p>\n<p>什么是MVC模式？<br>\n什么是MVVM模式？<br>\n什么是MVP模式？</p>\n</div>\n<hr>\n<p>在前端开发中，<code v-pre>MVC</code>、<code v-pre>MVVM</code> 和 <code v-pre>MVP</code> 是三种常见的软件设计模式，它们帮助开发者更高效地组织代码，提升代码的可维护性、可扩展性和可测试性。</p>\n<h3 id=\"mvc\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#mvc\"><span>MVC</span></a></h3>\n<h4 id=\"概念\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#概念\"><span>概念</span></a></h4>\n<p><code v-pre>MVC</code> 模式将应用程序分为三个主要部分：模型（<code v-pre>Model</code>）、视图（<code v-pre>View</code>）和控制器（<code v-pre>Controller</code>），各部分之间的职责明确且相互协作。</p>\n<ul>\n<li><strong>模型（<code v-pre>Model</code>）</strong>：负责处理应用程序的数据逻辑和业务规则，例如数据的存储、获取、更新和验证等操作。模型是独立于用户界面的，它可以被多个视图复用。</li>\n<li><strong>视图（<code v-pre>View</code>）</strong>：负责将模型中的数据以可视化的方式呈现给用户，通常是 HTML、CSS 和 JavaScript 构建的用户界面。视图只负责展示数据，不处理业务逻辑。</li>\n<li><strong>控制器（<code v-pre>Controller</code>）</strong>：作为模型和视图之间的桥梁，接收用户的输入（如点击事件、表单提交等），根据用户输入调用模型的相应方法进行数据处理，然后根据处理结果更新视图。</li>\n</ul>\n<h4 id=\"工作流程\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#工作流程\"><span>工作流程</span></a></h4>\n<ol>\n<li>用户与视图进行交互，触发相应的事件。</li>\n<li>视图将事件传递给控制器。</li>\n<li>控制器根据事件调用模型的方法进行数据处理。</li>\n<li>模型处理完数据后，将结果返回给控制器。</li>\n<li>控制器根据模型的结果更新视图。</li>\n</ol>\n<h4 id=\"优缺点\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#优缺点\"><span>优缺点</span></a></h4>\n<ul>\n<li><strong>优点</strong>：职责分离，便于代码的维护和扩展；模型和视图可以独立开发和测试。</li>\n<li><strong>缺点</strong>：控制器可能会变得过于庞大，包含过多的业务逻辑；视图和模型之间的耦合度较高，修改视图可能会影响到模型，反之亦然。</li>\n<li><strong>应用</strong>：传统后端框架（如 Spring MVC）。</li>\n</ul>\n<hr>\n<h3 id=\"mvvm\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#mvvm\"><span>MVVM</span></a></h3>\n<h4 id=\"概念-1\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#概念-1\"><span>概念</span></a></h4>\n<p><code v-pre>MVVM</code> 模式是在 <code v-pre>MVC</code> 模式的基础上发展而来的，它引入了视图模型（<code v-pre>ViewModel</code>）的概念，通过数据绑定和视图模型来实现视图和模型的分离。</p>\n<ul>\n<li><strong>模型（<code v-pre>Model</code>）</strong>：与 MVC 中的模型类似，负责处理数据和业务逻辑。</li>\n<li><strong>视图（<code v-pre>View</code>）</strong>：负责用户界面的展示，通常由 HTML 和 CSS 构建。</li>\n<li><strong>视图模型（<code v-pre>ViewModel</code>）</strong>：是视图和模型之间的桥梁，它包含了视图的状态和行为，并通过数据绑定机制将视图和模型连接起来。视图模型负责处理视图的交互逻辑，同时将视图的变化反映到模型中，反之亦然。</li>\n</ul>\n<h4 id=\"工作流程-1\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#工作流程-1\"><span>工作流程</span></a></h4>\n<ol>\n<li>视图模型通过数据绑定机制将模型的数据绑定到视图上，实现数据的自动更新。</li>\n<li>用户与视图进行交互，触发视图的事件。</li>\n<li>视图模型监听视图的事件，并根据事件更新模型的数据。</li>\n<li>模型的数据更新后，通过数据绑定机制自动更新视图。</li>\n</ol>\n<h4 id=\"优缺点-1\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#优缺点-1\"><span>优缺点</span></a></h4>\n<ul>\n<li><strong>优点</strong>：通过数据绑定和视图模型实现了视图和模型的解耦，降低了代码的耦合度，提高了代码的可维护性和可测试性；开发人员可以专注于业务逻辑的实现，而不需要手动操作 <code v-pre>DOM</code>。</li>\n<li><strong>缺点</strong>：数据绑定的实现可能会增加一定的性能开销；对于简单的应用程序，使用 MVVM 模式可能会显得过于复杂。</li>\n<li><strong>应用</strong>：现代前端框架（如 Vue、Angular、React + 状态管理）。</li>\n</ul>\n<hr>\n<h3 id=\"mvp\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#mvp\"><span>MVP</span></a></h3>\n<h4 id=\"概念-2\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#概念-2\"><span>概念</span></a></h4>\n<p><code v-pre>MVP</code> 模式也是从 <code v-pre>MVC</code> 模式演变而来的，它将控制器替换为了 <code v-pre>Presenter</code>，进一步强调了视图和模型的分离。</p>\n<ul>\n<li><strong>模型（<code v-pre>Model</code>）</strong>：同样负责数据和业务逻辑的处理。</li>\n<li><strong>视图（<code v-pre>View</code>）</strong>：负责用户界面的展示，只负责显示数据和接收用户的输入，不包含任何业务逻辑。</li>\n<li><strong>Presenter</strong>：作为视图和模型之间的中介，负责处理视图的交互逻辑和业务逻辑。Presenter 接收视图的事件，调用模型的方法进行数据处理，然后根据处理结果更新视图。</li>\n</ul>\n<h4 id=\"工作流程-2\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#工作流程-2\"><span>工作流程</span></a></h4>\n<ol>\n<li>用户与视图进行交互，触发视图的事件。</li>\n<li>视图将事件传递给 <code v-pre>Presenter</code>。</li>\n<li><code v-pre>Presenter</code> 根据事件调用模型的方法进行数据处理。</li>\n<li>模型处理完数据后，将结果返回给Presenter。</li>\n<li><code v-pre>Presenter</code> 根据模型的结果更新视图。</li>\n</ol>\n<h4 id=\"优缺点-2\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#优缺点-2\"><span>优缺点</span></a></h4>\n<ul>\n<li><strong>优点</strong>：视图和模型之间的耦合度较低，便于代码的维护和测试；<code v-pre>Presenter</code> 可以独立于视图和模型进行开发和测试。</li>\n</ul>\n<h2 id=\"commonjs-与-es6-导入模块的区别\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#commonjs-与-es6-导入模块的区别\"><span>CommonJS 与 ES6 导入模块的区别？</span></a></h2>\n<h3 id=\"commonjs-导入导出\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#commonjs-导入导出\"><span>CommonJS 导入导出</span></a></h3>\n<p>CommonJS 的导入导出是 Nodejs 早期原生支持的方式，ES6 的导入导出可以通过工具如 Babel 转换为 CommonJS 的方式。</p>\n<ul>\n<li>\n<ol>\n<li>导入导出语法</li>\n</ol>\n</li>\n</ul>\n<div class=\"language-js line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"js\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-js\"><span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">// 导出</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">const</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> name</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\"> '</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">moduleA</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">module</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">exports</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">  name</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">// 引入</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">const</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> moduleA</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> require</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">(</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">./moduleA</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">)</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>\n<ol start=\"2\">\n<li>特点</li>\n</ol>\n</li>\n<li>\n<p>CommonJS 还可以动态导入导出，通过条件判断甚至在函数体内导出模块。</p>\n<div class=\"language-js line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"js\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-js\"><span class=\"line\"><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\">if</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> (</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">condition</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">)</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">  exports</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">name</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\"> '</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">moduleA</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">}</span><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\"> else</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">  exports</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">name</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\"> '</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">moduleB</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">}</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">function</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> exportModule</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">()</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">  exports</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">name</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\"> '</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">moduleA</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">}</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n<li>\n<p>require 是运行时加载（同步加载），且在 require 时会加载和立即执行。</p>\n</li>\n<li>\n<p>导出的是值的拷贝，但是导入的引用类型共享同一引用。</p>\n</li>\n</ul>\n<h3 id=\"es6-导入导出\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#es6-导入导出\"><span>ES6 导入导出</span></a></h3>\n<ul>\n<li>\n<ol>\n<li>导入导出语法</li>\n</ol>\n</li>\n</ul>\n<div class=\"language-js line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"js\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-js\"><span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">// 导出</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\">export</span><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\"> const</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> name</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\"> '</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">moduleA</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">// 默认导出</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\">export</span><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\"> default</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\"> '</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">moduleA</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">// 引入</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\">import</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> name</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> }</span><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\"> from</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\"> '</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">./moduleA</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>\n<ol start=\"2\">\n<li>特点</li>\n</ol>\n</li>\n<li>\n<p>ES6 导入导出是静态的，即在编译时确定要导入的模块，而不是在运行时，这使得它可以在编译时确定依赖关系。所以它不允许像 CommonJS 那样动态导入导出模块。</p>\n</li>\n<li>\n<p>ES6 导入是异步加载，不会阻塞其他加载过程。</p>\n</li>\n<li>\n<p>ES6 导出的是值的引用，修改会影响所有导入该值的地方。</p>\n</li>\n</ul>\n<p>ESM 的设计更利于现代工具链优化和浏览器原生支持，是如今项目首推的导入导出方式。除非你有动态导入模块的场景，否则更推荐使用 ES6 导入导出的方式。</p>\n","env":{"base":"/","filePath":"D:/002-zhy-git/front-end-interview-docs/docs/basic/JavaScript/4.JavaScript/8.模块与工程化.md","filePathRelative":"basic/JavaScript/4.JavaScript/8.模块与工程化.md","frontmatter":{"title":"模块化与工程化","createTime":"2025/11/24 14:38:37","permalink":"/qa/javascript/ix80vlwr/","outline":2},"sfcBlocks":{"template":{"type":"template","content":"<template><h2 id=\"mvc、mvvm、mvp\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#mvc、mvvm、mvp\"><span>MVC、MVVM、MVP</span></a></h2>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">问题</p>\n<p>什么是MVC模式？<br>\n什么是MVVM模式？<br>\n什么是MVP模式？</p>\n</div>\n<hr>\n<p>在前端开发中，<code v-pre>MVC</code>、<code v-pre>MVVM</code> 和 <code v-pre>MVP</code> 是三种常见的软件设计模式，它们帮助开发者更高效地组织代码，提升代码的可维护性、可扩展性和可测试性。</p>\n<h3 id=\"mvc\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#mvc\"><span>MVC</span></a></h3>\n<h4 id=\"概念\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#概念\"><span>概念</span></a></h4>\n<p><code v-pre>MVC</code> 模式将应用程序分为三个主要部分：模型（<code v-pre>Model</code>）、视图（<code v-pre>View</code>）和控制器（<code v-pre>Controller</code>），各部分之间的职责明确且相互协作。</p>\n<ul>\n<li><strong>模型（<code v-pre>Model</code>）</strong>：负责处理应用程序的数据逻辑和业务规则，例如数据的存储、获取、更新和验证等操作。模型是独立于用户界面的，它可以被多个视图复用。</li>\n<li><strong>视图（<code v-pre>View</code>）</strong>：负责将模型中的数据以可视化的方式呈现给用户，通常是 HTML、CSS 和 JavaScript 构建的用户界面。视图只负责展示数据，不处理业务逻辑。</li>\n<li><strong>控制器（<code v-pre>Controller</code>）</strong>：作为模型和视图之间的桥梁，接收用户的输入（如点击事件、表单提交等），根据用户输入调用模型的相应方法进行数据处理，然后根据处理结果更新视图。</li>\n</ul>\n<h4 id=\"工作流程\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#工作流程\"><span>工作流程</span></a></h4>\n<ol>\n<li>用户与视图进行交互，触发相应的事件。</li>\n<li>视图将事件传递给控制器。</li>\n<li>控制器根据事件调用模型的方法进行数据处理。</li>\n<li>模型处理完数据后，将结果返回给控制器。</li>\n<li>控制器根据模型的结果更新视图。</li>\n</ol>\n<h4 id=\"优缺点\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#优缺点\"><span>优缺点</span></a></h4>\n<ul>\n<li><strong>优点</strong>：职责分离，便于代码的维护和扩展；模型和视图可以独立开发和测试。</li>\n<li><strong>缺点</strong>：控制器可能会变得过于庞大，包含过多的业务逻辑；视图和模型之间的耦合度较高，修改视图可能会影响到模型，反之亦然。</li>\n<li><strong>应用</strong>：传统后端框架（如 Spring MVC）。</li>\n</ul>\n<hr>\n<h3 id=\"mvvm\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#mvvm\"><span>MVVM</span></a></h3>\n<h4 id=\"概念-1\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#概念-1\"><span>概念</span></a></h4>\n<p><code v-pre>MVVM</code> 模式是在 <code v-pre>MVC</code> 模式的基础上发展而来的，它引入了视图模型（<code v-pre>ViewModel</code>）的概念，通过数据绑定和视图模型来实现视图和模型的分离。</p>\n<ul>\n<li><strong>模型（<code v-pre>Model</code>）</strong>：与 MVC 中的模型类似，负责处理数据和业务逻辑。</li>\n<li><strong>视图（<code v-pre>View</code>）</strong>：负责用户界面的展示，通常由 HTML 和 CSS 构建。</li>\n<li><strong>视图模型（<code v-pre>ViewModel</code>）</strong>：是视图和模型之间的桥梁，它包含了视图的状态和行为，并通过数据绑定机制将视图和模型连接起来。视图模型负责处理视图的交互逻辑，同时将视图的变化反映到模型中，反之亦然。</li>\n</ul>\n<h4 id=\"工作流程-1\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#工作流程-1\"><span>工作流程</span></a></h4>\n<ol>\n<li>视图模型通过数据绑定机制将模型的数据绑定到视图上，实现数据的自动更新。</li>\n<li>用户与视图进行交互，触发视图的事件。</li>\n<li>视图模型监听视图的事件，并根据事件更新模型的数据。</li>\n<li>模型的数据更新后，通过数据绑定机制自动更新视图。</li>\n</ol>\n<h4 id=\"优缺点-1\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#优缺点-1\"><span>优缺点</span></a></h4>\n<ul>\n<li><strong>优点</strong>：通过数据绑定和视图模型实现了视图和模型的解耦，降低了代码的耦合度，提高了代码的可维护性和可测试性；开发人员可以专注于业务逻辑的实现，而不需要手动操作 <code v-pre>DOM</code>。</li>\n<li><strong>缺点</strong>：数据绑定的实现可能会增加一定的性能开销；对于简单的应用程序，使用 MVVM 模式可能会显得过于复杂。</li>\n<li><strong>应用</strong>：现代前端框架（如 Vue、Angular、React + 状态管理）。</li>\n</ul>\n<hr>\n<h3 id=\"mvp\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#mvp\"><span>MVP</span></a></h3>\n<h4 id=\"概念-2\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#概念-2\"><span>概念</span></a></h4>\n<p><code v-pre>MVP</code> 模式也是从 <code v-pre>MVC</code> 模式演变而来的，它将控制器替换为了 <code v-pre>Presenter</code>，进一步强调了视图和模型的分离。</p>\n<ul>\n<li><strong>模型（<code v-pre>Model</code>）</strong>：同样负责数据和业务逻辑的处理。</li>\n<li><strong>视图（<code v-pre>View</code>）</strong>：负责用户界面的展示，只负责显示数据和接收用户的输入，不包含任何业务逻辑。</li>\n<li><strong>Presenter</strong>：作为视图和模型之间的中介，负责处理视图的交互逻辑和业务逻辑。Presenter 接收视图的事件，调用模型的方法进行数据处理，然后根据处理结果更新视图。</li>\n</ul>\n<h4 id=\"工作流程-2\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#工作流程-2\"><span>工作流程</span></a></h4>\n<ol>\n<li>用户与视图进行交互，触发视图的事件。</li>\n<li>视图将事件传递给 <code v-pre>Presenter</code>。</li>\n<li><code v-pre>Presenter</code> 根据事件调用模型的方法进行数据处理。</li>\n<li>模型处理完数据后，将结果返回给Presenter。</li>\n<li><code v-pre>Presenter</code> 根据模型的结果更新视图。</li>\n</ol>\n<h4 id=\"优缺点-2\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#优缺点-2\"><span>优缺点</span></a></h4>\n<ul>\n<li><strong>优点</strong>：视图和模型之间的耦合度较低，便于代码的维护和测试；<code v-pre>Presenter</code> 可以独立于视图和模型进行开发和测试。</li>\n</ul>\n<h2 id=\"commonjs-与-es6-导入模块的区别\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#commonjs-与-es6-导入模块的区别\"><span>CommonJS 与 ES6 导入模块的区别？</span></a></h2>\n<h3 id=\"commonjs-导入导出\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#commonjs-导入导出\"><span>CommonJS 导入导出</span></a></h3>\n<p>CommonJS 的导入导出是 Nodejs 早期原生支持的方式，ES6 的导入导出可以通过工具如 Babel 转换为 CommonJS 的方式。</p>\n<ul>\n<li>\n<ol>\n<li>导入导出语法</li>\n</ol>\n</li>\n</ul>\n<div class=\"language-js line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"js\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-js\"><span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">// 导出</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">const</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> name</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\"> '</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">moduleA</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">module</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">exports</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">  name</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">// 引入</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">const</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> moduleA</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> require</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">(</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">./moduleA</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">)</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>\n<ol start=\"2\">\n<li>特点</li>\n</ol>\n</li>\n<li>\n<p>CommonJS 还可以动态导入导出，通过条件判断甚至在函数体内导出模块。</p>\n<div class=\"language-js line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"js\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-js\"><span class=\"line\"><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\">if</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> (</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">condition</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">)</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">  exports</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">name</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\"> '</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">moduleA</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">}</span><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\"> else</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">  exports</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">name</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\"> '</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">moduleB</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">}</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">function</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> exportModule</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">()</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">  exports</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">name</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\"> '</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">moduleA</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">}</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n<li>\n<p>require 是运行时加载（同步加载），且在 require 时会加载和立即执行。</p>\n</li>\n<li>\n<p>导出的是值的拷贝，但是导入的引用类型共享同一引用。</p>\n</li>\n</ul>\n<h3 id=\"es6-导入导出\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#es6-导入导出\"><span>ES6 导入导出</span></a></h3>\n<ul>\n<li>\n<ol>\n<li>导入导出语法</li>\n</ol>\n</li>\n</ul>\n<div class=\"language-js line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"js\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-js\"><span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">// 导出</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\">export</span><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\"> const</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> name</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\"> '</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">moduleA</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">// 默认导出</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\">export</span><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\"> default</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\"> '</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">moduleA</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">// 引入</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\">import</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> name</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> }</span><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\"> from</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\"> '</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">./moduleA</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>\n<ol start=\"2\">\n<li>特点</li>\n</ol>\n</li>\n<li>\n<p>ES6 导入导出是静态的，即在编译时确定要导入的模块，而不是在运行时，这使得它可以在编译时确定依赖关系。所以它不允许像 CommonJS 那样动态导入导出模块。</p>\n</li>\n<li>\n<p>ES6 导入是异步加载，不会阻塞其他加载过程。</p>\n</li>\n<li>\n<p>ES6 导出的是值的引用，修改会影响所有导入该值的地方。</p>\n</li>\n</ul>\n<p>ESM 的设计更利于现代工具链优化和浏览器原生支持，是如今项目首推的导入导出方式。除非你有动态导入模块的场景，否则更推荐使用 ES6 导入导出的方式。</p>\n</template>","contentStripped":"<h2 id=\"mvc、mvvm、mvp\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#mvc、mvvm、mvp\"><span>MVC、MVVM、MVP</span></a></h2>\n<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">问题</p>\n<p>什么是MVC模式？<br>\n什么是MVVM模式？<br>\n什么是MVP模式？</p>\n</div>\n<hr>\n<p>在前端开发中，<code v-pre>MVC</code>、<code v-pre>MVVM</code> 和 <code v-pre>MVP</code> 是三种常见的软件设计模式，它们帮助开发者更高效地组织代码，提升代码的可维护性、可扩展性和可测试性。</p>\n<h3 id=\"mvc\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#mvc\"><span>MVC</span></a></h3>\n<h4 id=\"概念\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#概念\"><span>概念</span></a></h4>\n<p><code v-pre>MVC</code> 模式将应用程序分为三个主要部分：模型（<code v-pre>Model</code>）、视图（<code v-pre>View</code>）和控制器（<code v-pre>Controller</code>），各部分之间的职责明确且相互协作。</p>\n<ul>\n<li><strong>模型（<code v-pre>Model</code>）</strong>：负责处理应用程序的数据逻辑和业务规则，例如数据的存储、获取、更新和验证等操作。模型是独立于用户界面的，它可以被多个视图复用。</li>\n<li><strong>视图（<code v-pre>View</code>）</strong>：负责将模型中的数据以可视化的方式呈现给用户，通常是 HTML、CSS 和 JavaScript 构建的用户界面。视图只负责展示数据，不处理业务逻辑。</li>\n<li><strong>控制器（<code v-pre>Controller</code>）</strong>：作为模型和视图之间的桥梁，接收用户的输入（如点击事件、表单提交等），根据用户输入调用模型的相应方法进行数据处理，然后根据处理结果更新视图。</li>\n</ul>\n<h4 id=\"工作流程\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#工作流程\"><span>工作流程</span></a></h4>\n<ol>\n<li>用户与视图进行交互，触发相应的事件。</li>\n<li>视图将事件传递给控制器。</li>\n<li>控制器根据事件调用模型的方法进行数据处理。</li>\n<li>模型处理完数据后，将结果返回给控制器。</li>\n<li>控制器根据模型的结果更新视图。</li>\n</ol>\n<h4 id=\"优缺点\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#优缺点\"><span>优缺点</span></a></h4>\n<ul>\n<li><strong>优点</strong>：职责分离，便于代码的维护和扩展；模型和视图可以独立开发和测试。</li>\n<li><strong>缺点</strong>：控制器可能会变得过于庞大，包含过多的业务逻辑；视图和模型之间的耦合度较高，修改视图可能会影响到模型，反之亦然。</li>\n<li><strong>应用</strong>：传统后端框架（如 Spring MVC）。</li>\n</ul>\n<hr>\n<h3 id=\"mvvm\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#mvvm\"><span>MVVM</span></a></h3>\n<h4 id=\"概念-1\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#概念-1\"><span>概念</span></a></h4>\n<p><code v-pre>MVVM</code> 模式是在 <code v-pre>MVC</code> 模式的基础上发展而来的，它引入了视图模型（<code v-pre>ViewModel</code>）的概念，通过数据绑定和视图模型来实现视图和模型的分离。</p>\n<ul>\n<li><strong>模型（<code v-pre>Model</code>）</strong>：与 MVC 中的模型类似，负责处理数据和业务逻辑。</li>\n<li><strong>视图（<code v-pre>View</code>）</strong>：负责用户界面的展示，通常由 HTML 和 CSS 构建。</li>\n<li><strong>视图模型（<code v-pre>ViewModel</code>）</strong>：是视图和模型之间的桥梁，它包含了视图的状态和行为，并通过数据绑定机制将视图和模型连接起来。视图模型负责处理视图的交互逻辑，同时将视图的变化反映到模型中，反之亦然。</li>\n</ul>\n<h4 id=\"工作流程-1\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#工作流程-1\"><span>工作流程</span></a></h4>\n<ol>\n<li>视图模型通过数据绑定机制将模型的数据绑定到视图上，实现数据的自动更新。</li>\n<li>用户与视图进行交互，触发视图的事件。</li>\n<li>视图模型监听视图的事件，并根据事件更新模型的数据。</li>\n<li>模型的数据更新后，通过数据绑定机制自动更新视图。</li>\n</ol>\n<h4 id=\"优缺点-1\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#优缺点-1\"><span>优缺点</span></a></h4>\n<ul>\n<li><strong>优点</strong>：通过数据绑定和视图模型实现了视图和模型的解耦，降低了代码的耦合度，提高了代码的可维护性和可测试性；开发人员可以专注于业务逻辑的实现，而不需要手动操作 <code v-pre>DOM</code>。</li>\n<li><strong>缺点</strong>：数据绑定的实现可能会增加一定的性能开销；对于简单的应用程序，使用 MVVM 模式可能会显得过于复杂。</li>\n<li><strong>应用</strong>：现代前端框架（如 Vue、Angular、React + 状态管理）。</li>\n</ul>\n<hr>\n<h3 id=\"mvp\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#mvp\"><span>MVP</span></a></h3>\n<h4 id=\"概念-2\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#概念-2\"><span>概念</span></a></h4>\n<p><code v-pre>MVP</code> 模式也是从 <code v-pre>MVC</code> 模式演变而来的，它将控制器替换为了 <code v-pre>Presenter</code>，进一步强调了视图和模型的分离。</p>\n<ul>\n<li><strong>模型（<code v-pre>Model</code>）</strong>：同样负责数据和业务逻辑的处理。</li>\n<li><strong>视图（<code v-pre>View</code>）</strong>：负责用户界面的展示，只负责显示数据和接收用户的输入，不包含任何业务逻辑。</li>\n<li><strong>Presenter</strong>：作为视图和模型之间的中介，负责处理视图的交互逻辑和业务逻辑。Presenter 接收视图的事件，调用模型的方法进行数据处理，然后根据处理结果更新视图。</li>\n</ul>\n<h4 id=\"工作流程-2\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#工作流程-2\"><span>工作流程</span></a></h4>\n<ol>\n<li>用户与视图进行交互，触发视图的事件。</li>\n<li>视图将事件传递给 <code v-pre>Presenter</code>。</li>\n<li><code v-pre>Presenter</code> 根据事件调用模型的方法进行数据处理。</li>\n<li>模型处理完数据后，将结果返回给Presenter。</li>\n<li><code v-pre>Presenter</code> 根据模型的结果更新视图。</li>\n</ol>\n<h4 id=\"优缺点-2\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#优缺点-2\"><span>优缺点</span></a></h4>\n<ul>\n<li><strong>优点</strong>：视图和模型之间的耦合度较低，便于代码的维护和测试；<code v-pre>Presenter</code> 可以独立于视图和模型进行开发和测试。</li>\n</ul>\n<h2 id=\"commonjs-与-es6-导入模块的区别\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#commonjs-与-es6-导入模块的区别\"><span>CommonJS 与 ES6 导入模块的区别？</span></a></h2>\n<h3 id=\"commonjs-导入导出\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#commonjs-导入导出\"><span>CommonJS 导入导出</span></a></h3>\n<p>CommonJS 的导入导出是 Nodejs 早期原生支持的方式，ES6 的导入导出可以通过工具如 Babel 转换为 CommonJS 的方式。</p>\n<ul>\n<li>\n<ol>\n<li>导入导出语法</li>\n</ol>\n</li>\n</ul>\n<div class=\"language-js line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"js\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-js\"><span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">// 导出</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">const</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> name</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\"> '</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">moduleA</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">module</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">exports</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">  name</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">// 引入</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">const</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> moduleA</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> require</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">(</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">./moduleA</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">)</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>\n<ol start=\"2\">\n<li>特点</li>\n</ol>\n</li>\n<li>\n<p>CommonJS 还可以动态导入导出，通过条件判断甚至在函数体内导出模块。</p>\n<div class=\"language-js line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"js\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-js\"><span class=\"line\"><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\">if</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> (</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">condition</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">)</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">  exports</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">name</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\"> '</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">moduleA</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">}</span><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\"> else</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">  exports</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">name</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\"> '</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">moduleB</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">}</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">function</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> exportModule</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">()</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#998418;--shiki-dark:#B8A965\">  exports</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">name</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\"> '</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">moduleA</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">}</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div></li>\n<li>\n<p>require 是运行时加载（同步加载），且在 require 时会加载和立即执行。</p>\n</li>\n<li>\n<p>导出的是值的拷贝，但是导入的引用类型共享同一引用。</p>\n</li>\n</ul>\n<h3 id=\"es6-导入导出\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#es6-导入导出\"><span>ES6 导入导出</span></a></h3>\n<ul>\n<li>\n<ol>\n<li>导入导出语法</li>\n</ol>\n</li>\n</ul>\n<div class=\"language-js line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"js\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code class=\"language-js\"><span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">// 导出</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\">export</span><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\"> const</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> name</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\"> '</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">moduleA</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">// 默认导出</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\">export</span><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\"> default</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\"> '</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">moduleA</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\">// 引入</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\">import</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> name</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> }</span><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\"> from</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\"> '</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">./moduleA</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">'</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><ul>\n<li>\n<ol start=\"2\">\n<li>特点</li>\n</ol>\n</li>\n<li>\n<p>ES6 导入导出是静态的，即在编译时确定要导入的模块，而不是在运行时，这使得它可以在编译时确定依赖关系。所以它不允许像 CommonJS 那样动态导入导出模块。</p>\n</li>\n<li>\n<p>ES6 导入是异步加载，不会阻塞其他加载过程。</p>\n</li>\n<li>\n<p>ES6 导出的是值的引用，修改会影响所有导入该值的地方。</p>\n</li>\n</ul>\n<p>ESM 的设计更利于现代工具链优化和浏览器原生支持，是如今项目首推的导入导出方式。除非你有动态导入模块的场景，否则更推荐使用 ES6 导入导出的方式。</p>\n","tagOpen":"<template>","tagClose":"</template>"},"script":null,"scriptSetup":null,"scripts":[],"styles":[],"customBlocks":[]},"content":"## MVC、MVVM、MVP\n\n::: tip 问题\n什么是MVC模式？  \n什么是MVVM模式？  \n什么是MVP模式？  \n:::\n\n---\n\n在前端开发中，`MVC`、`MVVM` 和 `MVP` 是三种常见的软件设计模式，它们帮助开发者更高效地组织代码，提升代码的可维护性、可扩展性和可测试性。\n\n### MVC\n#### 概念 \n`MVC` 模式将应用程序分为三个主要部分：模型（`Model`）、视图（`View`）和控制器（`Controller`），各部分之间的职责明确且相互协作。\n- **模型（`Model`）**：负责处理应用程序的数据逻辑和业务规则，例如数据的存储、获取、更新和验证等操作。模型是独立于用户界面的，它可以被多个视图复用。\n- **视图（`View`）**：负责将模型中的数据以可视化的方式呈现给用户，通常是 HTML、CSS 和 JavaScript 构建的用户界面。视图只负责展示数据，不处理业务逻辑。\n- **控制器（`Controller`）**：作为模型和视图之间的桥梁，接收用户的输入（如点击事件、表单提交等），根据用户输入调用模型的相应方法进行数据处理，然后根据处理结果更新视图。\n\n#### 工作流程\n1. 用户与视图进行交互，触发相应的事件。\n2. 视图将事件传递给控制器。\n3. 控制器根据事件调用模型的方法进行数据处理。\n4. 模型处理完数据后，将结果返回给控制器。\n5. 控制器根据模型的结果更新视图。\n\n#### 优缺点\n- **优点**：职责分离，便于代码的维护和扩展；模型和视图可以独立开发和测试。\n- **缺点**：控制器可能会变得过于庞大，包含过多的业务逻辑；视图和模型之间的耦合度较高，修改视图可能会影响到模型，反之亦然。\n- **应用**：传统后端框架（如 Spring MVC）。\n\n---\n\n### MVVM\n#### 概念\n`MVVM` 模式是在 `MVC` 模式的基础上发展而来的，它引入了视图模型（`ViewModel`）的概念，通过数据绑定和视图模型来实现视图和模型的分离。\n- **模型（`Model`）**：与 MVC 中的模型类似，负责处理数据和业务逻辑。\n- **视图（`View`）**：负责用户界面的展示，通常由 HTML 和 CSS 构建。\n- **视图模型（`ViewModel`）**：是视图和模型之间的桥梁，它包含了视图的状态和行为，并通过数据绑定机制将视图和模型连接起来。视图模型负责处理视图的交互逻辑，同时将视图的变化反映到模型中，反之亦然。\n\n#### 工作流程\n1. 视图模型通过数据绑定机制将模型的数据绑定到视图上，实现数据的自动更新。\n2. 用户与视图进行交互，触发视图的事件。\n3. 视图模型监听视图的事件，并根据事件更新模型的数据。\n4. 模型的数据更新后，通过数据绑定机制自动更新视图。\n\n#### 优缺点\n- **优点**：通过数据绑定和视图模型实现了视图和模型的解耦，降低了代码的耦合度，提高了代码的可维护性和可测试性；开发人员可以专注于业务逻辑的实现，而不需要手动操作 `DOM`。\n- **缺点**：数据绑定的实现可能会增加一定的性能开销；对于简单的应用程序，使用 MVVM 模式可能会显得过于复杂。\n- **应用**：现代前端框架（如 Vue、Angular、React + 状态管理）。\n\n---\n\n### MVP\n#### 概念\n`MVP` 模式也是从 `MVC` 模式演变而来的，它将控制器替换为了 `Presenter`，进一步强调了视图和模型的分离。\n- **模型（`Model`）**：同样负责数据和业务逻辑的处理。\n- **视图（`View`）**：负责用户界面的展示，只负责显示数据和接收用户的输入，不包含任何业务逻辑。\n- **Presenter**：作为视图和模型之间的中介，负责处理视图的交互逻辑和业务逻辑。Presenter 接收视图的事件，调用模型的方法进行数据处理，然后根据处理结果更新视图。\n\n#### 工作流程\n1. 用户与视图进行交互，触发视图的事件。\n2. 视图将事件传递给 `Presenter`。\n3. `Presenter` 根据事件调用模型的方法进行数据处理。\n4. 模型处理完数据后，将结果返回给Presenter。\n5. `Presenter` 根据模型的结果更新视图。\n\n#### 优缺点\n- **优点**：视图和模型之间的耦合度较低，便于代码的维护和测试；`Presenter` 可以独立于视图和模型进行开发和测试。\n\n## CommonJS 与 ES6 导入模块的区别？\n\n### CommonJS 导入导出\n\nCommonJS 的导入导出是 Nodejs 早期原生支持的方式，ES6 的导入导出可以通过工具如 Babel 转换为 CommonJS 的方式。\n\n- 1. 导入导出语法\n\n```js\n// 导出\nconst name = 'moduleA'\nmodule.exports = {\n  name\n}\n\n// 引入\nconst moduleA = require('./moduleA')\n```\n\n- 2. 特点\n\n- CommonJS 还可以动态导入导出，通过条件判断甚至在函数体内导出模块。\n  ```js\n  if (condition) {\n    exports.name = 'moduleA'\n  } else {\n    exports.name = 'moduleB'\n  }\n  function exportModule() {\n    exports.name = 'moduleA'\n  }\n  ```\n\n- require 是运行时加载（同步加载），且在 require 时会加载和立即执行。\n- 导出的是值的拷贝，但是导入的引用类型共享同一引用。\n\n### ES6 导入导出\n\n- 1. 导入导出语法\n\n```js\n// 导出\nexport const name = 'moduleA'\n// 默认导出\nexport default 'moduleA'\n\n// 引入\nimport { name } from './moduleA'\n```\n\n- 2. 特点\n\n- ES6 导入导出是静态的，即在编译时确定要导入的模块，而不是在运行时，这使得它可以在编译时确定依赖关系。所以它不允许像 CommonJS 那样动态导入导出模块。\n- ES6 导入是异步加载，不会阻塞其他加载过程。\n- ES6 导出的是值的引用，修改会影响所有导入该值的地方。\n\nESM 的设计更利于现代工具链优化和浏览器原生支持，是如今项目首推的导入导出方式。除非你有动态导入模块的场景，否则更推荐使用 ES6 导入导出的方式。","excerpt":"","includedFiles":[],"tasklistId":0,"title":"","headers":[{"level":2,"title":"MVC、MVVM、MVP","slug":"mvc、mvvm、mvp","link":"#mvc、mvvm、mvp","children":[{"level":3,"title":"MVC","slug":"mvc","link":"#mvc","children":[]},{"level":3,"title":"MVVM","slug":"mvvm","link":"#mvvm","children":[]},{"level":3,"title":"MVP","slug":"mvp","link":"#mvp","children":[]}]},{"level":2,"title":"CommonJS 与 ES6 导入模块的区别？","slug":"commonjs-与-es6-导入模块的区别","link":"#commonjs-与-es6-导入模块的区别","children":[{"level":3,"title":"CommonJS 导入导出","slug":"commonjs-导入导出","link":"#commonjs-导入导出","children":[]},{"level":3,"title":"ES6 导入导出","slug":"es6-导入导出","link":"#es6-导入导出","children":[]}]}]}}
